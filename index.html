<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Shapes</title>
    <link rel="stylesheet" href="includes/style.css">
</head>

<body onload="init()">
    <h1>Graphics Final Project</h1>
    <h4>Submitted by Maoz Tamir and Yaniv Sapir</h4>
    <div id="wrapper">
        <div id="controlPanelComponent">
            <h3><u>Control Panel</u></h3>
            <p><u>EX1</u></p>
            <label>Color:
                <select id="chooseColor">
                    <option>Black</option>
                    <option>Red</option>
                    <option>Green</option>
                    <option>Blue</option>
                    <option>Yellow</option>
                </select>
            </label>
            <form><label>Function:
                <select id="chooseFunction">
                    <option value="0"></option>
                    <option value="1">add pixel</option>
                    <option value="2">my line</option>
                    <option value="3">my circle</option>
                    <option value="4">regular polygon</option>
                    <option value="5">bezier</option>
                </select>
            </label></form>
            <label>Input for functions: <input id="poly"></label><br><br>
            <div id="packageDiv">
                <p><u>EX2</u></p>
                <button id="packageButton">Load Package</button>
            </div><br>
            <div id="threeDeeDiv">
                <p><u>EX3</u></p>
                <button id="threeDeeButton">Load Package</button>
            </div><br>
            <div><button id="clear">Clean the board</button></div>
        </div>
        <div id="canvasComponent">
            <canvas id="board"></canvas>
        </div>
    </div>
    <div id="light" class="white_content">
        <a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';
        document.getElementById('fade').style.display='none'" class="textRight">Close</a>
        <h3><u>Functions Guide Ex2</u></h3>
        <p><b>First load the picture</b></p>
        <p>1. For moving the picture, press anywhere on the screen.</p>
        <p>2. For zooming the picture, press anywhere and it will zoom according to the clicked position.
        The default degree is 20, if you would like to change it you can insert an input</p>
        <p>3. For rotating the picture, press anywhere and it will zoom according to the clicked position.</p>
        <p>4. For mirroring the picture, press anywhere on the screen and it will be mirrored and moved depended
            on the difference between the initial point and the clicked position</p>
        <p>5. For shearing the picture, click and drag left/right. the picture will be sheared on the x axis</p>
    </div>
    <div id="light2" class="white_content">
        <a href="javascript:void(0)" onclick="document.getElementById('light2').style.display='none';
        document.getElementById('fade').style.display='none'" class="textRight">Close</a>
        <h3><u>Functions Guide Ex3</u></h3>
    </div>
    <div id="fade" class="black_overlay"></div>

    <script>
        /* EX1 vars */
        // canvas vars
        var canvas = document.querySelector('#board');
        var ctx = canvas.getContext('2d');
        var canvasWidth = 800;
        var canvasHeight = 600;
        // select color var
        var chooseColor = document.querySelector("#chooseColor");
        var color;
        // array to hold the click points
        var clicks = [];
        // click point structures
        var point = {
            x: 0,
            y: 0
        };
        var secondPoint = JSON.parse(JSON.stringify(point));
        var thirdPoint  = JSON.parse(JSON.stringify(point));
        var fourPoint   = JSON.parse(JSON.stringify(point));
        var fivePoint   = JSON.parse(JSON.stringify(point));
        // clean button var
        var clear = document.querySelector("#clear");
        // choose function form var
        var chooseFunction = document.querySelector("#chooseFunction");
        // input var
        var polyInput = document.querySelector('#poly');
        var globalN = 6;

        /* EX1 listeners */
        clear.addEventListener("click", clean);
        chooseColor.addEventListener("change",getColor);
        canvas.addEventListener("click",getClickPosition);
        chooseFunction.addEventListener("change",checkChosenFunc);
        polyInput.addEventListener("change",updatePoly);

        /* EX1 functions */
        /* initialize */
        function init(){
            setCanvasSize();
            getColor();
        }

        /* set canvas dimensions */
        function setCanvasSize() {
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }

        /* get selected color */
        function getColor() {
            color = color === "" ? "black" : chooseColor.options[chooseColor.selectedIndex].text;
            //console.log("color changed to "+color);
        }

        /* reset the canvas */
        function clean() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            clicks=[];
            secondPoint.x =0;
            secondPoint.y =0;
            thirdPoint.x = 0;
            thirdPoint.y = 0;
            fourPoint.x = 0;
            fourPoint.y = 0;
            fivePoint.x = 0;
            fivePoint.y = 0;
            console.log("clear the canvas and reset global vars");
        }

        /* update input function */
        function updatePoly() {
            globalN = parseFloat(polyInput.value);
        }

        /* set point from the event */
        function getRelativePoint(e) {
            if (e.pageX || e.pageY) {
                point.x = e.pageX;
                point.y = e.pageY;
            } else {
                point.x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                point.y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
            }
            point.x -= canvas.offsetLeft;
            point.y -= canvas.offsetTop;
        }

        /* get click position and set point cords */
        function getClickPosition(e) {
            //reset click array if more than 4
            if (clicks.length===4) clicks=[];
            getRelativePoint(e);
            var click = [point.x,point.y];
            //console.log(click);
            clicks.push(click);
            console.log("the array of point clicks: " + clicks);
            isPicMenuExist === false ? checkChosenFunc() : checkChosenFuncPic();
        }

        /* add pixel to the screen */
        function addPixel(x,y) {
            if (x===0 && y===0) return;
            if ((y>canvasHeight) || (x>canvasWidth)) return;
            //console.log("print " + x + "," + y);
            ctx.fillStyle = color;
            ctx.fillRect(x, y, 1, 1);
        }

        /* print custom line */
        function myLine(x1,y1,x2,y2) {
            var temp;
            //get the higher x value between the points
            if(x2<x1) {
                temp=x1;
                x1=x2;
                x2=temp;
                temp=y1;
                y1=y2;
                y2=temp;
            }
            var slope = (y2-y1)/(x2-x1); //the slope
            var x = x1; // print start point x
            var y = y1; // print start point y
            // print line algoritem
            while(x<=x2) {
                if ((slope<=1) && (slope>=-1)) {
                    y = y1+slope*(x-x1);
                    addPixel(x,y);
                    x++;
                } else if( slope>1 ) {
                    x=(y-y1+slope*x1)/slope;
                    addPixel(x,y);
                    y++;
                } else if( slope<-1 ) {
                    x=(y-y1+slope*x1)/slope;
                    addPixel(x,y);
                    y--;
                }
            }
        }

        /* create circle using pixel method */
        function myCircle(x1,y1,x2,y2) {
            var radius = Math.sqrt(Math.pow((x2-x1),2) + Math.pow((y2-y1),2));
            var y = 0;
            var inCircle = 1-radius;
            while(y<=radius)	{
                // 8 areas of calculation
                addPixel( radius + x1, y + y1);
                addPixel( y + x1, radius + y1);
                addPixel(-radius + x1, y + y1);
                addPixel(-y + x1, radius + y1);
                addPixel(-radius + x1,-y + y1);
                addPixel(-y + x1,-radius + y1);
                addPixel( radius + x1,-y + y1);
                addPixel( y + x1,-radius + y1);
                y++;
                if (inCircle<=0) {
                    inCircle += 2*y+1;
                } else {
                    radius--;
                    inCircle += 2*(y-radius)+1;
                }
            }
        }

        /* create regular polygon using line method */
        function myRegularPolygon(x1,y1,x2,y2,n) {
            if (n<3) {
                alert("polygon value must be greater than 2");
                return;
            }
            var x = [];
            var y = [];
            var centre = [x2,y2];
            var radius = Math.sqrt(Math.pow((x2-x1),2) + Math.pow((y2-y1),2));
            var theta = 2*Math.PI/n;
            for (var i = -1; i <= n; i++) {
                x[i] = radius * Math.cos(2*Math.PI*i/n + theta) + centre[0];
                y[i] = radius * Math.sin(2*Math.PI*i/n + theta) + centre[1];
                var a = x[i-1];
                var b = y[i-1];
                console.log(a,b,x[i],y[i]);
                myLine(a,b,x[i],y[i]);
            }
        }

        /* create bezier curve using 4 points and 0<t<1 */
        function bezier(x1, y1, x2, y2, x3, y3, x4, y4, t) {
            if ((t>1) || (t<0)) return;
            var temp = 0;
            var xOne = Math.pow((1-temp),3)*x1+3*(Math.pow((1-temp),2))*temp*x2+3*(1-temp)*Math.pow(temp,2)*x3+Math.pow(temp,3)*x4;
            var yOne = Math.pow((1-temp),3)*y1+3*(Math.pow((1-temp),2))*temp*y2+3*(1-temp)*Math.pow(temp,2)*y3+Math.pow(temp,3)*y4;
            while(temp<1) {
                temp = temp+t;
                var xTwo = Math.pow((1-temp),3)*x1+3*(Math.pow((1-temp),2))*temp*x2+3*(1-temp)*Math.pow(temp,2)*x3+Math.pow(temp,3)*x4;
                var yTwo = Math.pow((1-temp),3)*y1+3*(Math.pow((1-temp),2))*temp*y2+3*(1-temp)*Math.pow(temp,2)*y3+Math.pow(temp,3)*y4;
                myLine(xOne, yOne, xTwo, yTwo);
                xOne = xTwo;
                yOne = yTwo;
            }
        }

        /* get 2 points from clicks array and set them to draw a line */
        function setTwoPoints() {
            if (clicks.length === 2) {
                var tempA = clicks.pop();
                var tempB = clicks.pop();
                secondPoint.y = tempA[1];
                secondPoint.x = tempA[0];
                //console.log(clicks);
                thirdPoint.y = tempB[1];
                thirdPoint.x = tempB[0];
                //console.log(thirdPoint.x,thirdPoint.y,secondPoint.x,secondPoint.y);
            }
        }

        /* get 4 points from clicks array and set them to draw a line */
        function setFourPoints() {
            if (clicks.length === 4) {
                var tempA = clicks.pop();
                var tempB = clicks.pop();
                var tempC = clicks.pop();
                var tempD = clicks.pop();
                secondPoint.y = tempA[1];
                secondPoint.x = tempA[0];
                thirdPoint.y = tempB[1];
                thirdPoint.x = tempB[0];
                fourPoint.y = tempC[1];
                fourPoint.x = tempC[0];
                fivePoint.y = tempD[1];
                fivePoint.x = tempD[0];
                //console.log(clicks);
            }
        }

        /* check chosen function */
        function checkChosenFunc() {
            var func = chooseFunction.options[chooseFunction.selectedIndex].value;
            //console.log("function number " + func);
            switch(func) {
                case "0":
                    console.log("please choose a function");
                    break;
                case "1":
                    addPixel(point.x,point.y);
                    break;
                case "2":
                    setTwoPoints();
                    if ((secondPoint.x !== 0)&&(secondPoint.y !== 0)&&(thirdPoint.x !== 0)&&(thirdPoint.y !== 0))
                        myLine(thirdPoint.x,thirdPoint.y,secondPoint.x,secondPoint.y);
                    break;
                case "3":
                    setTwoPoints();
                    if ((secondPoint.x !== 0)&&(secondPoint.y !== 0)&&(thirdPoint.x !== 0)&&(thirdPoint.y !== 0))
                        myCircle(thirdPoint.x,thirdPoint.y,secondPoint.x,secondPoint.y);
                    break;
                case "4":
                    setTwoPoints();
                    if ((secondPoint.x !== 0)&&(secondPoint.y !== 0)&&(thirdPoint.x !== 0)&&(thirdPoint.y !== 0))
                        myRegularPolygon(thirdPoint.x,thirdPoint.y,secondPoint.x,secondPoint.y,globalN);
                    break;
                case "5":
                    setFourPoints();
                    if ((secondPoint.x !== 0)&&(secondPoint.y !== 0)&&(thirdPoint.x !== 0)&&(thirdPoint.y !== 0)&&
                        (fourPoint.x !== 0)&&(fourPoint.y !== 0)&&(fivePoint.x !== 0)&&(fivePoint.y !== 0))
                            bezier(thirdPoint.x,thirdPoint.y,secondPoint.x,secondPoint.y,
                                fourPoint.x,fourPoint.y,fivePoint.x,fivePoint.y,globalN);
                    break;
            }
        }

        /* EX2 vars */
        // package loader button
        var packageButton = document.querySelector("#packageButton");
        // check if menu already exist
        var isPicMenuExist= false;
        //arrays that hold the picture's shape kinds
        var picture = [];
        var circlesInPic = [];
        var linesInPic = [];
        var bezierInPic = [];
        //initial ship points
        var initialShipPointX=418;
        var initialShipPointY=266;
        //rotate default degree
        var globalDegree = 20;
        //shearing vars
        var mouseDownX = 0;
        var mouseDownY = 0;
        var mouseUpX = 0;

        /* EX2 listeners */
        packageButton.addEventListener("click",loadPackage);

        /* EX2 functions */
        /* load everything related to the ship package */
        function loadPackage(){
            createPicOptionMenu(); //load the package
            loadUserManual(); //load guide to use the functions
        }

        /* dynamic create the ship picture menu, and only single time */
        function createPicOptionMenu(){
            //console.log("loaded menu");
            if (!isPicMenuExist) {
                var packageDiv = document.getElementById("packageDiv");
                //Create array of options to be added
                var array = ["","Load File","Move Picture","Center Picture","Zoom In","Zoom Out",
                    "Rotate Right","Rotate Left","Mirror xAxis","Mirror yAxis","Shearing X"];

                //Create and append select list
                var selectList = document.createElement("select");
                selectList.id = "shipOptions";
                packageDiv.appendChild(selectList);

                //Create and append the options
                for (var i = 0; i < array.length; i++) {
                    var option = document.createElement("option");
                    option.value = i;
                    option.text = array[i];
                    selectList.appendChild(option);
                }

                //Create input for ship rotations
                var shipLabel = document.createElement("label");
                var inputArea = document.createElement("input");
                shipLabel.innerHTML="Input for functions: ";
                inputArea.id = "shipInput";
                packageDiv.appendChild(shipLabel);
                shipLabel.appendChild(inputArea);

                isPicMenuExist=true;
                //after creating the menu, adding an event listener for the option list
                selectList.addEventListener("change",checkChosenFuncPic);
                //create event listener for ship input
                var shipInput = document.querySelector('#shipInput');
                shipInput.addEventListener("change",updateShipInput);
            }
        }

        /* will load guide about how to use the package */
        function loadUserManual(){
            console.log("load the guide");
            document.getElementById('light').style.display='block';
            document.getElementById('fade').style.display='block';
        }

        /* ajax call to load json file */
        function fetchJSONFile(path, callback) {
            var httpRequest = new XMLHttpRequest();
            httpRequest.onreadystatechange = function() {
                if (httpRequest.readyState === 4) {
                    if (httpRequest.status === 200) {
                        var data = JSON.parse(httpRequest.responseText);
                        if (callback) callback(data);
                    }
                }
            };
            httpRequest.open('GET', path);
            httpRequest.send();
        }

        /* print the vector picture to the screen */
        function drawPic () {
            var shapeCounter = 0;
            while(shapeCounter<picture[0].length) {
                myCircle(picture[0][shapeCounter][0],picture[0][shapeCounter][1],picture[0][shapeCounter][2],picture[0][shapeCounter][3]);
                shapeCounter++;
            }
            shapeCounter=0;
            while(shapeCounter<picture[1].length) {
                myLine(picture[1][shapeCounter][0],picture[1][shapeCounter][1],picture[1][shapeCounter][2],picture[1][shapeCounter][3]);
                shapeCounter++;
            }
            shapeCounter=0;
            while(shapeCounter<picture[2].length) {
                bezier(picture[2][shapeCounter][0],picture[2][shapeCounter][1],picture[2][shapeCounter][2],picture[2][shapeCounter][3],picture[2][shapeCounter][4],
                    picture[2][shapeCounter][5],picture[2][shapeCounter][6],picture[2][shapeCounter][7],picture[2][shapeCounter][8]);
                shapeCounter++;
            }
        }

        /* load json file and split it into arrays of shapes[circles,lines,beziers] */
        function loadAndSplit(){
            fetchJSONFile('includes/ship.json',function (data) {
                console.log(data);
                if (data.circle !== undefined) {
                    // get circles
                    for(var row=0; row<data.circle.length; row++) {
                        circlesInPic[row] = [];
                        circlesInPic[row][0] = data.circle[row].x1;
                        circlesInPic[row][1] = data.circle[row].y1;
                        circlesInPic[row][2] = data.circle[row].x2;
                        circlesInPic[row][3] = data.circle[row].y2;
                    }
                }
                if (data.line !== undefined) {
                    //get lines
                    for(row=0;row<data.line.length;row++) {
                        linesInPic[row] = [];
                        linesInPic[row][0] = data.line[row].x1;
                        linesInPic[row][1] = data.line[row].y1;
                        linesInPic[row][2] = data.line[row].x2;
                        linesInPic[row][3] = data.line[row].y2;
                    }
                }
                if (data.curve !== undefined) {
                    /// get curves
                    for(row=0;row<data.curve.length;row++) {
                        bezierInPic[row] = [];
                        bezierInPic[row][0] = data.curve[row].x1;
                        bezierInPic[row][1] = data.curve[row].y1;
                        bezierInPic[row][2] = data.curve[row].x2;
                        bezierInPic[row][3] = data.curve[row].y2;
                        bezierInPic[row][4] = data.curve[row].x3;
                        bezierInPic[row][5] = data.curve[row].y3;
                        bezierInPic[row][6] = data.curve[row].x4;
                        bezierInPic[row][7] = data.curve[row].y4;
                        bezierInPic[row][8] = data.curve[row].t;
                    }
                }
                picture[0] = circlesInPic; //will hold the circles inside the shape
                picture[1] = linesInPic;    //will hold the lines inside the shape
                picture[2] = bezierInPic;   //will hold the bezier inside the shape
                drawPic();
            });
        }

        /*  move picture to different location */
        function movePic(newX, newY) {
            //clear canvas
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            //calculate the x and y position difference between the initial point and the click
            const deferenceX= initialShipPointX-newX;
            const deferenceY= initialShipPointY-newY;
            //console.log("the difference is: "+deferenceX+","+deferenceY);
            for (var j=0;j<3;j++){  //loop over shapes kind array
                for (var i=0;i<picture[j].length;i++) { //loop over the rows of each shape array
                    var t;
                    if (j===2) { // if the shape is bezier, avoid touching the "t" parameter
                        for (t = 0; t < picture[j][i].length-1; t++) {
                            t % 2 === 0 ? picture[j][i][t] -= deferenceX : picture[j][i][t] -= deferenceY;
                        }
                    } else{
                        for (t = 0; t < picture[j][i].length; t++) {
                            t % 2 === 0 ? picture[j][i][t] -= deferenceX : picture[j][i][t] -= deferenceY;
                        }
                    }
                }
            }
            drawPic();
            initialShipPointX=newX;
            initialShipPointY=newY;
            //console.log("new point "+initialShipPointX+","+initialShipPointY);
        }

        /*  zoom in/out depends on a click location */
        function zoomPic(zoomX, zoomY,zoomIndex ) {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            const deferenceX= initialShipPointX-zoomX;
            const deferenceY= initialShipPointY-zoomY;

            for (var j=0;j<3;j++){  //loop over shapes kind array
                for (var i=0;i<picture[j].length;i++) { //loop over the rows of each shape array
                    var t;
                    if (j===2) { // if the shape is bezier, avoid touching the "t" parameter
                        for (t = 0; t < picture[j][i].length-1; t++) {
                            if(t % 2 === 0){
                                picture[j][i][t] = initialShipPointX+ ((picture[j][i][t] -initialShipPointX)*zoomIndex)+ deferenceX * zoomIndex;
                            }else{
                                picture[j][i][t] = initialShipPointY+ ((picture[j][i][t] -initialShipPointY)*zoomIndex)+ deferenceY * zoomIndex;
                            }
                        }
                    } else{
                        for (t = 0; t < picture[j][i].length; t++) {
                            if(t % 2 === 0){
                                picture[j][i][t] = initialShipPointX+ ((picture[j][i][t] -initialShipPointX)*zoomIndex)+ deferenceX * zoomIndex;
                            }else{
                                picture[j][i][t] = initialShipPointY+ ((picture[j][i][t] -initialShipPointY)*zoomIndex)+ deferenceY * zoomIndex;
                            }
                        }
                    }
                }
            }
            drawPic();
            initialShipPointX=zoomX;
            initialShipPointY=zoomY;
        }

        /*  center the picture */
        function centerPic(){
            point.x=canvasWidth/2;
            point.y=canvasHeight/2;
            movePic(point.x,point.y);
        }

        /*  update the rotation value */
        function updateShipInput() {
            globalDegree = shipInput.value;
        }

        /* calculation algoritem function for rotation */
        function calculationForRotate(x,y,rotateRad,j,i,t){
            var radius = Math.sqrt(Math.pow((picture[j][i][t]-x),2)+Math.pow((picture[j][i][t+1]-y),2));
            var current = picture[j][i][t];
            if((picture[j][i][t+1]-y)<0) {
                picture[j][i][t] = radius*(Math.cos(rotateRad-(Math.acos((Math.pow((picture[j][i][t]-x),2)
                            +Math.pow(radius,2)-Math.pow((picture[j][i][t+1]-y),2))/(2*(picture[j][i][t]-x)*radius)))))+x;
                picture[j][i][t+1] = radius*(Math.sin(rotateRad-(Math.acos((Math.pow((current-x),2)
                            +Math.pow(radius,2)-Math.pow((picture[j][i][t+1]-y),2))/(2*(current-x)*radius)))))+y;
            } else {
                picture[j][i][t] = radius*(Math.cos(rotateRad+(Math.acos((Math.pow((picture[j][i][t]-x),2)
                            +Math.pow(radius,2)-Math.pow((picture[j][i][t+1]-y),2))/(2*(picture[j][i][t]-x)*radius)))))+x;
                picture[j][i][t+1] = radius*(Math.sin(rotateRad+(Math.acos((Math.pow((current-x),2)
                            +Math.pow(radius,2)-Math.pow((picture[j][i][t+1]-y),2))/(2*(current-x)*radius)))))+y;
            }
        }

        /*  rotate the picture */
        function rotatePic(x, y , degree) {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            var rotateRad = (degree*Math.PI)/180;

            for (var j=0;j<3;j++){  //loop over shapes kind array
                for (var i=0;i<picture[j].length;i++) { //loop over the rows of each shape array
                    var t;
                    if (j===2) { // if the shape is bezier, avoid touching the "t" parameter
                        for (t = 0; t < picture[j][i].length-1; t+=2) {
                            calculationForRotate(x,y,rotateRad,j,i,t);
                        }
                    } else{
                        for (t = 0; t < picture[j][i].length; t+=2) {
                            calculationForRotate(x,y,rotateRad,j,i,t);
                        }
                    }
                }
            }
            drawPic();
        }

        /*  mirror the picture */
        function mirrorPic(x,y,axis) {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            var axisToChange = axis === 0 ? 0 : 1;  //if axis===0 mirror x, else mirror y
            var axisValue = axis === 0 ? x : y;     //if axis===0 mirror x, else mirror y
            for (var j=0;j<3;j++){  //loop over shapes kind array
                for (var i=0;i<picture[j].length;i++) { //loop over the rows of each shape array
                    var t = axisToChange;
                    if (j===2) { // if the shape is bezier, avoid touching the "t" parameter
                        for (t ; t < picture[j][i].length-1; t+=2) {
                            picture[j][i][t]=picture[j][i][t]-(picture[j][i][t]-axisValue)*2;
                        }
                    } else{
                        for (t; t < picture[j][i].length; t+=2) {
                            picture[j][i][t]=picture[j][i][t]-(picture[j][i][t]-axisValue)*2;
                        }
                    }
                }
            }
            drawPic();
        }

        /*  shearing function, relative to the button of the ship */
        function shearingPic (holdClickX, releaseClickX, holdClickY) {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            var shearPoint = 416; // bottom of the ship, shearing will be relative to this position
            var ShearingIndex = (holdClickX-releaseClickX)/(shearPoint-holdClickY);

            for (var j=0;j<3;j++){  //loop over shapes kind array
                for (var i=0;i<picture[j].length;i++) { //loop over the rows of each shape array
                    var t;
                    if (j===2) { // if the shape is bezier, avoid touching the "t" parameter
                        for (t=0; t < picture[j][i].length-1; t+=2) {
                            picture[j][i][t] = picture[j][i][t]+(ShearingIndex*(picture[j][i][t+1]-shearPoint))
                        }
                    } else{
                        for (t=0; t < picture[j][i].length; t+=2) {
                            picture[j][i][t] = picture[j][i][t]+(ShearingIndex*(picture[j][i][t+1]-shearPoint))
                        }
                    }
                }
            }
            drawPic();
            canvas.removeEventListener("mousedown",mouseDown);
            canvas.removeEventListener("mouseup",mouseUp);
        }

        /*  set point for mouse down */
        function mouseDown(e){
            getRelativePoint(e);
            mouseDownX = point.x;
            mouseDownY = point.y;
        }

        /*  set point for mouse up */
        function mouseUp(e){
            getRelativePoint(e);
            mouseUpX = point.x;
            shearingPic(mouseDownX,mouseUpX,mouseDownY);
        }

        /*  ship json file transformation functions */
        function checkChosenFuncPic(){
            var func2 = shipOptions.options[shipOptions.selectedIndex].value;
            //console.log("function: " + func2);
            switch(func2) {
                case "0":
                    console.log("please choose a function");
                    break;
                case "1":
                    loadAndSplit();
                    break;
                case "2":
                    point.x===0 && point.y===0 ? alert("Select point to move the object into") : movePic(point.x,point.y);
                    break;
                case "3":
                    centerPic();
                    break;
                case "4":
                    point.x===0 && point.y===0 ? alert("Select the zoom point") : zoomPic(point.x,point.y,1.05);
                    break;
                case "5":
                    point.x===0 && point.y===0 ? alert("Select the zoom point") : zoomPic(point.x,point.y,0.95);
                    break;
                case "6":
                    point.x===0 && point.y===0 ? alert("Select rotate left point") : rotatePic(point.x,point.y,globalDegree);
                    break;
                case "7":
                    point.x===0 && point.y===0 ? alert("Select rotate right point") : rotatePic(point.x,point.y,-1*globalDegree);
                    break;
                case "8":
                    point.x===0 && point.y===0 ? alert("Select Mirror x axis") : mirrorPic(point.x,point.y,0);
                    break;
                case "9":
                    point.x===0 && point.y===0 ? alert("Select Mirror y axis") : mirrorPic(point.x,point.y,1);
                    break;
                case "10":
                    canvas.addEventListener("mousedown",mouseDown);
                    canvas.addEventListener("mouseup",mouseUp);
                    break;
            }
        }

        /* EX3 vars */
        // package loader button
        var threeDeeButton = document.querySelector("#threeDeeButton");
        var isThreeDeeMenuExist= false;
        var threeDeePic = [];
        var polyArr = [];
        var sortZArr = [];
        var opacity = 1;
        var cavalierAndCabinetDeg;
        var projectionNum = 0;
        var threeDeeInputX = 0;
        var threeDeeInputY = 0;
        var threeDeeInputZ = 0;

        /* EX3 listeners */
        threeDeeButton.addEventListener("click",loadThreeDeePackage);

        /* EX3 functions */
        /* load all the things that required for the 3D package */
        function loadThreeDeePackage(){
            loadThreeDeeManual();
            createThreeDeeOptionMenu();
            loadThreeDee();
        }

        /*load 3D exercise manual*/
        function loadThreeDeeManual(){
            console.log("loaded ThreeDee Manual");
            document.getElementById('light2').style.display='block';
            document.getElementById('fade').style.display='block';
        }

        /* dynamic create the 3D package menu, and only single time */
        function createThreeDeeOptionMenu(){
            if (!isThreeDeeMenuExist) {
                var threeDeeDiv = document.getElementById("threeDeeDiv");
                //Create array of options to be added
                var array = ["","perspective","parallel","cabinet","cavalier"];

                //Create and append select list
                var selectList = document.createElement("select");
                selectList.id = "threeDeeOptions";
                threeDeeDiv.appendChild(selectList);

                //Create and append the options
                for (var i = 0; i < array.length; i++) {
                    var option = document.createElement("option");
                    option.value = i;
                    option.text = array[i];
                    selectList.appendChild(option);
                }

                var br = document.createElement("br");
                threeDeeDiv.appendChild(br);

                //create zoom in
                var zoomIn = document.createElement("button");
                zoomIn.id = "zoomIn3d";
                zoomIn.innerHTML="zoom in";
                threeDeeDiv.appendChild(zoomIn);

                //create zoom out
                var zoomOut = document.createElement("button");
                zoomOut.id = "zoomOut3d";
                zoomOut.innerHTML="zoom out";
                threeDeeDiv.appendChild(zoomOut);

                //create move3d
                var move = document.createElement("button");
                move.id = "move3d";
                move.innerHTML="move 3d";
                threeDeeDiv.appendChild(move);

                //create rotatex
                var rotaX = document.createElement("button");
                rotaX.id = "rotaX";
                rotaX.innerHTML="rotate x";
                threeDeeDiv.appendChild(rotaX);

                //create rotatey
                var rotaY = document.createElement("button");
                rotaY.id = "rotaY";
                rotaY.innerHTML="rotate y";
                threeDeeDiv.appendChild(rotaY);

                //create rotatez
                var rotaZ = document.createElement("button");
                rotaZ.id = "rotaZ";
                rotaZ.innerHTML="rotate z";
                threeDeeDiv.appendChild(rotaZ);

                //create line break
                threeDeeDiv.appendChild(br);

                //Create input for functions
                var threeDeeLabel = document.createElement("label");
                var inputArea = document.createElement("input");
                threeDeeLabel.innerHTML="X: ";
                inputArea.id = "threeDeeInputX";
                threeDeeDiv.appendChild(threeDeeLabel);
                threeDeeLabel.appendChild(inputArea);
                var threeDeeLabel2 = document.createElement("label");
                var inputArea2 = document.createElement("input");
                threeDeeLabel2.innerHTML="Y: ";
                inputArea2.id = "threeDeeInputY";
                threeDeeDiv.appendChild(threeDeeLabel2);
                threeDeeLabel2.appendChild(inputArea2);
                var threeDeeLabel3 = document.createElement("label");
                var inputArea3 = document.createElement("input");
                threeDeeLabel3.innerHTML="Z: ";
                inputArea3.id = "threeDeeInputZ";
                threeDeeDiv.appendChild(threeDeeLabel3);
                threeDeeLabel3.appendChild(inputArea3);

                isThreeDeeMenuExist=true;

                //after creating the menu, adding an event listener for the option list
                selectList.addEventListener("change",checkChosenFuncThreeDee);

                //buttons vars and event listeners
                var zoomIn3d = document.querySelector('#zoomIn3d');
                zoomIn3d.addEventListener("click",zoomInThreeD);
                var zoomOut3d = document.querySelector('#zoomOut3d');
                zoomOut3d.addEventListener("click",zoomOutThreeD);
                var move3d = document.querySelector('#move3d');
                move3d.addEventListener("click",moveThreeD);
                var rotateX = document.querySelector('#rotaX');
                rotateX.addEventListener("click",rotateThreeDeeX);
                var rotateY = document.querySelector('#rotaY');
                rotateY.addEventListener("click",rotateThreeDeeY);
                var rotateZ = document.querySelector('#rotaZ');
                rotateZ.addEventListener("click",rotateThreeDeeZ);

                //create event listener for threeDee inputs
                var threeDeeInputX = document.querySelector('#threeDeeInputX');
                threeDeeInputX.addEventListener("change",updateThreeDeeInputX);
                var threeDeeInputY = document.querySelector('#threeDeeInputY');
                threeDeeInputY.addEventListener("change",updateThreeDeeInputY);
                var threeDeeInputZ = document.querySelector('#threeDeeInputZ');
                threeDeeInputZ.addEventListener("change",updateThreeDeeInputZ);
            }
        }

        /*  3D json file functions */
        function checkChosenFuncThreeDee(){
            var func3 = threeDeeOptions.options[threeDeeOptions.selectedIndex].value;
            //console.log("function: " + func2);
            switch(func3) {
                case "0":
                    console.log("please choose a function");
                    break;
                case "1":
                    perspective();
                    sortPolyZ();
                    printThreeDee();
                    projectionNum = 0;
                    break;
                case "2":
                    parallel();
                    sortPolyZ();
                    printThreeDee();
                    projectionNum = 3;
                    break;
                case "3":
                    cabinet();
                    sortPolyZ();
                    printThreeDee();
                    projectionNum = 2;
                    break;
                case "4":
                    cavalier();
                    sortPolyZ();
                    printThreeDee();
                    projectionNum = 1;
                    break;
            }
        }

        /* update 3d input x */
        function updateThreeDeeInputX() {
            threeDeeInputX = threeDeeInputX.value;
        }

        /* update 3d input y */
        function updateThreeDeeInputY() {
            threeDeeInputY = threeDeeInputY.value;
        }

        /* update 3d input z */
        function updateThreeDeeInputZ() {
            threeDeeInputZ = threeDeeInputZ.value;
        }

        /* load 3D json into an array */
        function loadThreeDee(){
            fetchJSONFile('includes/threeDee.json',function (data) {
                if(data.polygon !== undefined) {
                    for(var i=0; i<data.polygon.length; i++) {
                        threeDeePic[i] = [];
                        for(var k=0; k<data.polygon[i].length; k++) {
                            threeDeePic[i][k]= data.polygon[i][k];
                        }
                        for(var j=0; j<5; j++) {
                            threeDeePic[i][threeDeePic[i].length]=0;
                        }
                    }
                }
                polyNormal();
                polyMaxZ();
            });
        }

        /* calculate the normal for each polygon */
        function polyNormal() {
            for(var i=0; i<threeDeePic.length;i++) {
                var vector1 = [];
                var vector2 = [];
                for(var k=0;k<3;k++) {
                    vector1[k] = threeDeePic[i][k+3]-threeDeePic[i][k];
                    vector2[k] = threeDeePic[i][k+6]-threeDeePic[i][k+3];
                }
                threeDeePic[i][threeDeePic[i].length-3] = vector1[1]*vector2[2]-vector1[2]*vector2[1];
                threeDeePic[i][threeDeePic[i].length-2] = vector1[2]*vector2[0]-vector1[0]*vector2[2];
                threeDeePic[i][threeDeePic[i].length-1] = vector1[0]*vector2[1]-vector1[1]*vector2[0];
            }
        }

        /* find the max z */
        function polyMaxZ() {
            for(var i=0; i<threeDeePic.length;i++) {
                threeDeePic[i][threeDeePic[i].length-5] = Number.MIN_VALUE;
                for (var k=2; k<threeDeePic[i].length-6; k+=3) {
                    if (threeDeePic[i][threeDeePic[i].length-5] < threeDeePic[i][k]) {
                        threeDeePic[i][threeDeePic[i].length-5] = threeDeePic[i][k];
                    }
                }
            }
        }

        /* perspective projection */
        function perspective() {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            //copy to poly working array
            for(var j=0; j<threeDeePic.length; j++) {
                polyArr[j] = [];
                for(var t=0; t<threeDeePic[j].length; t++) {
                    polyArr[j][t] = threeDeePic[j][t];
                }
            }
            //calculation
            for (var i=0;i<polyArr.length;i++){
                for (var k=0;k<polyArr[i].length-7;k+=3){
                    polyArr[i][k] = (polyArr[i][k])/(1+polyArr[i][k+2]/600);
                    polyArr[i][k+1] = (polyArr[i][k+1])/(1+polyArr[i][k+2]/600);
                }
            }
        }

        /* parallel projection */
        function parallel() {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            //copy to poly working array
            for(var j=0; j<threeDeePic.length; j++) {
                polyArr[j] = [];
                for(var t=0; t<threeDeePic[j].length; t++) {
                    polyArr[j][t] = threeDeePic[j][t];
                }
            }
            //calculation
            for(var i=0;i<polyArr.length;i++) {
                for (var k=0;k<polyArr[i].length-7;k+=3) {
                    polyArr[i][k] = polyArr[i][k];
                    polyArr[i][k+1] = polyArr[i][k+1];
                }
            }
        }

        /* cabinet projection */
        function cabinet() {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            ctx.globalAlpha = 1;
            //copy to poly working array
            for(var j=0; j<threeDeePic.length; j++) {
                polyArr[j] = [];
                for(var t=0; t<threeDeePic[j].length; t++) {
                    polyArr[j][t] = threeDeePic[j][t];
                }
            }
            //calculation
            var angle;
            angle = cavalierAndCabinetDeg === undefined ? angle = 45 : angle = cavalierAndCabinetDeg;
            var angleX = Math.cos(-angle*Math.PI/180);
            var angleY = Math.sin(-angle*Math.PI/180);
            for (var i=0;i<polyArr.length;i++) {
                for (var k=0;k<polyArr[i].length-7;k+=3){
                    polyArr[i][k] = (polyArr[i][k])+(polyArr[i][k+2]/2*angleX);
                    polyArr[i][k+1] = (polyArr[i][k+1])+(polyArr[i][k+2]/2*angleY);
                }
            }
        }

        /* cavalier projection */
        function cavalier() {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            ctx.globalAlpha = 1;
            //copy to poly working array
            for(var j=0; j<threeDeePic.length; j++) {
                polyArr[j] = [];
                for(var t=0; t<threeDeePic[j].length; t++) {
                    polyArr[j][t] = threeDeePic[j][t];
                }
            }
            //calculation
            var angle;
            angle = cavalierAndCabinetDeg === undefined ? angle = 45 : angle = cavalierAndCabinetDeg;
            var angleX = Math.cos(-angle*Math.PI/180);
            var angleY = Math.sin(-angle*Math.PI/180);
            for (var i=0;i<polyArr.length;i++) {
                for (var k=0;k<polyArr[i].length-7;k+=3){
                    polyArr[i][k] = (polyArr[i][k])+(polyArr[i][k+2]*angleX);
                    polyArr[i][k+1] = (polyArr[i][k+1])+(polyArr[i][k+2]*angleY);
                }
            }
        }

        /* zoom out multiply */
        function zoomOutThreeD(){
            Resize3D(0.9);
        }

        /* zoom in multiply */
        function zoomInThreeD(){
            Resize3D(1.1);
        }

        /* zoom function */
        function Resize3D(zoomIndex){
            var Zoom3d = zoomIndex;
            for(var i=0; i<threeDeePic.length;i++) {
                for(var k=0;k<threeDeePic[i].length-7;k+=3) {
                    threeDeePic[i][k] = threeDeePic[i][k]*Zoom3d;
                    threeDeePic[i][k+1] = threeDeePic[i][k+1]*Zoom3d;
                    threeDeePic[i][k+2] = threeDeePic[i][k+2]*Zoom3d;
                }
            }
            polyNormal();
            polyMaxZ();
            checkProjection();
        }

        /* moving objects on the grid */
        function moveThreeD(){
            for(var i=0; i<threeDeePic.length;i++) {
                for(var k=0; k<threeDeePic[i].length-7; k+=3) {
                    threeDeePic[i][k] = threeDeePic[i][k]+parseFloat(threeDeeInputX);
                    threeDeePic[i][k+1] = threeDeePic[i][k+1]+parseFloat(threeDeeInputY);
                    threeDeePic[i][k+2] = threeDeePic[i][k+2]+parseFloat(threeDeeInputZ);
                }
            }
            polyNormal();
            checkProjection();
        }

        /* rotate3d X */
        function rotateThreeDeeX() {
            var userDeg;
            if(threeDeeInputX === undefined || threeDeeInputX === 0) {
                userDeg = 5;
            } else {
                userDeg = threeDeeInputX;
            }
            var rotY = 0;
            var rotZ = 0;
            for(var i=0; i<threeDeePic.length;i++) {
                for(var k=0;k<threeDeePic[i].length-7;k+=3) {
                    rotY = threeDeePic[i][k+1];
                    rotZ = threeDeePic[i][k+2];
                    threeDeePic[i][k+1] = rotY*Math.cos(userDeg*Math.PI/180)+rotZ*(-1*Math.sin(userDeg*Math.PI/180));
                    threeDeePic[i][k+2] = rotY*Math.sin(userDeg*Math.PI/180)+rotZ*Math.cos(userDeg*Math.PI/180);
                }
                rotY = threeDeePic[i][threeDeePic[i].length-2];
                rotZ = threeDeePic[i][threeDeePic[i].length-1];
                // Y normal rotation
                threeDeePic[i][threeDeePic[i].length-2] = rotY*Math.cos(userDeg*Math.PI/180)+rotZ*(-1*Math.sin(userDeg*Math.PI/180));
                // Z normal rotation
                threeDeePic[i][threeDeePic[i].length-1] = rotY*Math.sin(userDeg*Math.PI/180)+rotZ*Math.cos(userDeg*Math.PI/180);
            }

            polyMaxZ();
            checkProjection();
        }

        /* rotate3d Y */
        function rotateThreeDeeY() {
            var userDeg;
            if(threeDeeInputY === undefined || threeDeeInputY === 0) {
                userDeg = 5;
            } else {
                userDeg = threeDeeInputY;
            }
            var rotX = 0;
            var rotZ = 0;
            for(var i=0; i<threeDeePic.length;i++) {
                for(var k=0;k<threeDeePic[i].length-7;k+=3) {
                    rotX = threeDeePic[i][k];
                    rotZ = threeDeePic[i][k+2];
                    threeDeePic[i][k] = rotX*Math.cos(AngleRotXUser*Math.PI/180)+rotZ*(-1*Math.sin(AngleRotXUser*Math.PI/180));
                    threeDeePic[i][k+2] = rotX*Math.sin(AngleRotXUser*Math.PI/180)+rotZ*Math.cos(AngleRotXUser*Math.PI/180);
                }
                rotX = threeDeePic[i][threeDeePic[i].length-3];
                rotZ = threeDeePic[i][threeDeePic[i].length-1];
                // X normal rotation
                threeDeePic[i][threeDeePic[i].length-3] = rotX*Math.cos(userDeg*Math.PI/180)+rotZ*(-1*Math.sin(userDeg*Math.PI/180));
                // Z normal rotation
                threeDeePic[i][threeDeePic[i].length-1] = rotX*Math.sin(userDeg*Math.PI/180)+rotZ*Math.cos(userDeg*Math.PI/180);
            }

            polyMaxZ();
            checkProjection();
        }

        /* rotate3d Z */
        function rotateThreeDeeZ() {
            var userDeg;
            if(threeDeeInputZ === undefined || threeDeeInputZ === 0) {
                userDeg = 5;
            } else {
                userDeg = threeDeeInputZ;
            }
            var rotX = 0;
            var rotY = 0;
            for(var i=0; i<threeDeePic.length;i++)
            {
                for(var k=0;k<threeDeePic[i].length-7;k+=3)
                {
                    rotX = threeDeePic[i][k];
                    rotY = threeDeePic[i][k+1];
                    threeDeePic[i][k] = rotX*Math.cos(AngleRotXUser*Math.PI/180)+rotY*Math.sin(AngleRotXUser*Math.PI/180);
                    threeDeePic[i][k+1] = rotX*(-1*Math.sin(AngleRotXUser*Math.PI/180))+rotY*Math.cos(AngleRotXUser*Math.PI/180);
                }
                rotX = threeDeePic[i][threeDeePic[i].length-3];
                rotY = threeDeePic[i][threeDeePic[i].length-2];
                // X normal rotation
                threeDeePic[i][threeDeePic[i].length-3] = rotX*Math.cos(userDeg*Math.PI/180)+rotY*Math.sin(userDeg*Math.PI/180);
                // Y normal rotation
                threeDeePic[i][threeDeePic[i].length-2] = rotX*(-1*Math.sin(userDeg*Math.PI/180))+rotY*Math.cos(userDeg*Math.PI/180);			          		
            }

            polyMaxZ();
            checkProjection();
        }

        /* check in which projection to display the functions */
        function checkProjection(){
            if (projectionNum === 1) {
                cavalier();
            } else if(projectionNum === 2) {
                cabinet();
            } else if(projectionNum === 3) {
                parallel();
            } else {
                perspective();
            }
            sortPolyZ();
            printThreeDee();
        }

        /* sorting polygons by their max Z */
        function sortPolyZ() {
            for (var i=0;i<polyArr.length-1;i++) {
                for (var j=0;j<polyArr.length-i-1;j++) {
                    if(polyArr[j][polyArr[j].length-5] < polyArr[j+1][polyArr[j].length-5]) {
                        //if the arrays lengths are equal
                        if (polyArr[j].length === polyArr[j+1].length) {
                            for(var k=0;k<polyArr[j].length;k++) {
                                sortZArr[k] = polyArr[j][k];
                                polyArr[j][k] = polyArr[j+1][k];
                                polyArr[j+1][k] = sortZArr[k];
                            }
                        } else {
                            var temp1 = [];
                            var temp2 = [];
                            for(var s1=0;s1<polyArr[j].length;s1++) {
                                temp1[s1] = polyArr[j][s1];
                            }
                            for(var s2=0;s2<polyArr[j+1].length;s2++) {
                                temp2[s2] = polyArr[j+1][s2];
                            }
                            polyArr[j] = [];
                            polyArr[j+1] = [];
                            for(var s3=0;s3<temp2.length;s3++) {
                                polyArr[j][s3] = temp2[s3];
                            }
                            for(var s4=0;s4<temp1.length;s4++) {
                                polyArr[j+1][s4] = temp1[s4];
                            }
                        }
                    }
                }
            }
        }

        /* print 3D objects to the screen */
        function printThreeDee(){
            console.log("printThreeDee");
            ctx.globalAlpha = 1;
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 1;
            visiblePoly();
            for (var i=0;i<polyArr.length;i++){
                if(polyArr[i][polyArr[i].length-4] === 1) {
                    var k = 3;
                    ctx.beginPath();   //first point of polygon
                    ctx.moveTo(polyArr[i][0]+canvasWidth/2, polyArr[i][1]+canvasWidth/2);
                    while(k<polyArr[i].length-7) {
                        ctx.lineTo(polyArr[i][k]+canvasWidth/2, polyArr[i][k+1]+canvasWidth/2);
                        k += 3;
                    }
                    ctx.closePath();
                    ctx.globalAlpha = 1;
                    ctx.stroke();
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = polyArr[i][polyArr[i].length-6];
                    ctx.fill();
                }
            }
        }

        /* function to checks which polygon will be displayed */
        function visiblePoly() {
            var normalX = 0;
            var normalY = 0;
            var normalZ = 0;
            var vectorX = 0;
            var vectorY = 0;
            var vectorZ = 0;
            var visiPol = 0;
            var normalUserDeg = 0;
            var angle;
            angle = cavalierAndCabinetDeg === undefined ? angle = 45 : angle = cavalierAndCabinetDeg;
            var angleX = Math.cos(-angle*Math.PI/180);
            var angleY = Math.sin(-angle*Math.PI/180);
            var xtovec = 0;
            var ytovec = 0;
            var ztovec = 0;
            // cavalier projection
            if (projectionNum === 1) {
                xtovec = 5000*angleX;
                ytovec = 5000*angleY;
                ztovec = 5000;
            }
            // cabinet projection
            else if(projectionNum === 2) {
                xtovec = 5000/2*angleX;
                ytovec = 5000/2*angleY;
                ztovec = 5000;
            }
            //not caval & not cabinet
            else {
                xtovec = 0;
                ytovec = 0;
                ztovec = 800;
            }
            //check the angle between C.O.P & Polygon Normal
            for(var i=0; i<polyArr.length;i++) {
                normalX = polyArr[i][polyArr[i].length-3];
                normalY = polyArr[i][polyArr[i].length-2];
                normalZ = polyArr[i][polyArr[i].length-1];
                vectorX = polyArr[i][0]-(xtovec);
                vectorY = polyArr[i][1]-(ytovec);
                vectorZ = polyArr[i][2]-(-ztovec);

                visiPol = Math.acos((vectorX*normalX+vectorY*normalY+vectorZ*normalZ)/(Math.sqrt(Math.pow(vectorX,2)+
                        Math.pow(vectorY,2)+Math.pow(vectorZ,2))*Math.sqrt(Math.pow(normalX,2)+
                        Math.pow(normalY,2)+Math.pow(normalZ,2)))); // calc angle between normal and C.O.P
                normalUserDeg = visiPol*(180/Math.PI); // from rad to deg
                //works with opacity
                if(opacity!==undefined && opacity<1 && opacity>=0) {
                    polyArr[i][polyArr[i].length-4]=1;
                } else if(Math.cos(normalUserDeg*(Math.PI/180))<0) {
                    polyArr[i][polyArr[i].length-4] = 1;
                } else{
                    polyArr[i][polyArr[i].length-4] = 0;
                }
            }
        }

    </script>
</body>
</html>
