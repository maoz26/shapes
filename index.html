<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Shapes</title>
    <link rel="stylesheet" href="includes/style.css">
</head>

<body onload="init()">
    <h1>Graphics EX2</h1>
    <h4>Submitted by Maoz Tamir and Yaniv Sapir</h4>
    <div id="wrapper">
        <div id="controlPanelComponent">
            <h3><u>Control Panel</u></h3>
            <form><p><u>EX1</u></p><label>Color:
                <select id="chooseColor">
                    <option>Black</option>
                    <option>Red</option>
                    <option>Green</option>
                    <option>Blue</option>
                    <option>Yellow</option>
                </select>
            </label></form>
            <form><label>Function:
                <select id="chooseFunction">
                    <option value="0"></option>
                    <option value="1">add pixel</option>
                    <option value="2">my line</option>
                    <option value="3">my circle</option>
                    <option value="4">regular polygon</option>
                    <option value="5">bezier</option>
                </select>
            </label></form>
            <label>Input for functions: <input id="poly"></label><br><br>
            <div id="packageDiv"><p><u>EX2</u></p><button id="packageButton">Load Package</button></div>
            <div><button id="clear">Clean the board</button></div>
        </div>
        <div id="canvasComponent">
            <canvas id="board"></canvas>
        </div>
    </div>
    <div id="light" class="white_content">
        <a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';
        document.getElementById('fade').style.display='none'" class="textRight">Close</a>
        <h3><u>functions guide</u></h3>
        <p><b>First load the picture</b></p>
        <p>1. For moving the picture, press anywhere on the screen.</p>
        <p>2. For zooming the picture, press anywhere and it will zoom according to the clicked position.
        The default degree is 20, if you would like to change it you can insert an input</p>
        <p>3. For rotating the picture, press anywhere and it will zoom according to the clicked position.</p>
        <p>4. For mirroring the picture, press anywhere on the screen and it will be mirrored and moved depended
            on the difference between the initial point and the clicked position</p>
        <p>5. For shearing the picture, click and drag left/right. the picture will be sheared on the x axis</p>
    </div>
    <div id="fade" class="black_overlay"></div>

    <script>
        //////////
        // vars //
        //////////

        /* EX1 vars */
        // canvas vars
        var canvas = document.querySelector('#board');
        var ctx = canvas.getContext('2d');
        var canvasWidth = 800;
        var canvasHeight = 600;
        // select color var
        var chooseColor = document.querySelector("#chooseColor");
        var color;
        // array to hold the click points
        var clicks = [];
        // click point structures
        var point = {
            x: 0,
            y: 0
        };
        var secondPoint = JSON.parse(JSON.stringify(point));
        var thirdPoint  = JSON.parse(JSON.stringify(point));
        var fourPoint   = JSON.parse(JSON.stringify(point));
        var fivePoint   = JSON.parse(JSON.stringify(point));
        // clean button var
        var clear = document.querySelector("#clear");
        // choose function form var
        var chooseFunction = document.querySelector("#chooseFunction");
        // input var
        var polyInput = document.querySelector('#poly');
        var globalN = 6;

        /* EX2 vars */
        // package loader button
        var packageButton = document.querySelector("#packageButton");
        // check if menu already exist
        var isPicMenuExist= false;
        //arrays that hold the picture's shape kinds
        var picture = [];
        var circlesInPic = [];
        var linesInPic = [];
        var bezierInPic = [];
        //initial ship points
        var initialShipPointX=418;
        var initialShipPointY=266;
        //rotate default degree
        var globalDegree = 20;
        //shearing vars
        var mouseDownX = 0;
        var mouseDownY = 0;
        var mouseUpX = 0;

        /////////////////////
        // event listeners //
        /////////////////////

        /* EX1 listeners */
        clear.addEventListener("click", clean);
        chooseColor.addEventListener("change",getColor);
        canvas.addEventListener("click",getClickPosition);
        chooseFunction.addEventListener("change",checkChosenFunc);
        polyInput.addEventListener("change",updatePoly);

        /* EX2 listeners */
        packageButton.addEventListener("click",loadPackage);

        ///////////////
        // functions //
        ///////////////

        /* EX1 functions */
        /* initialize */
        function init(){
            setCanvasSize();
            getColor();
        }

        /* set canvas dimensions */
        function setCanvasSize() {
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }

        /* get selected color */
        function getColor() {
            color = color === "" ? "black" : chooseColor.options[chooseColor.selectedIndex].text;
            //console.log("color changed to "+color);
        }

        /* reset the canvas */
        function clean() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            clicks=[];
            secondPoint.x =0;
            secondPoint.y =0;
            thirdPoint.x = 0;
            thirdPoint.y = 0;
            fourPoint.x = 0;
            fourPoint.y = 0;
            fivePoint.x = 0;
            fivePoint.y = 0;
            console.log("clear the canvas and reset global vars");
        }

        /* update input function */
        function updatePoly() {
            globalN = parseFloat(polyInput.value);
        }

        /* set point from the event */
        function getRelativePoint(e) {
            if (e.pageX || e.pageY) {
                point.x = e.pageX;
                point.y = e.pageY;
            } else {
                point.x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                point.y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
            }
            point.x -= canvas.offsetLeft;
            point.y -= canvas.offsetTop;
        }

        /* get click position and set point cords */
        function getClickPosition(e) {
            //reset click array if more than 4
            if (clicks.length===4) clicks=[];
            getRelativePoint(e);
            var click = [point.x,point.y];
            //console.log(click);
            clicks.push(click);
            console.log("the array of point clicks: " + clicks);
            isPicMenuExist === false ? checkChosenFunc() : checkChosenFuncPic();
        }

        /* add pixel to the screen */
        function addPixel(x,y) {
            if (x===0 && y===0) return;
            if ((y>canvasHeight) || (x>canvasWidth)) return;
            //console.log("print " + x + "," + y);
            ctx.fillStyle = color;
            ctx.fillRect(x, y, 1, 1);
        }

        /* print custom line */
        function myLine(x1,y1,x2,y2) {
            var temp;
            //get the higher x value between the points
            if(x2<x1) {
                temp=x1;
                x1=x2;
                x2=temp;
                temp=y1;
                y1=y2;
                y2=temp;
            }
            var slope = (y2-y1)/(x2-x1); //the slope
            var x = x1; // print start point x
            var y = y1; // print start point y
            // print line algoritem
            while(x<=x2) {
                if ((slope<=1) && (slope>=-1)) {
                    y = y1+slope*(x-x1);
                    addPixel(x,y);
                    x++;
                } else if( slope>1 ) {
                    x=(y-y1+slope*x1)/slope;
                    addPixel(x,y);
                    y++;
                } else if( slope<-1 ) {
                    x=(y-y1+slope*x1)/slope;
                    addPixel(x,y);
                    y--;
                }
            }
        }

        /* create circle using pixel method */
        function myCircle(x1,y1,x2,y2) {
            var radius = Math.sqrt(Math.pow((x2-x1),2) + Math.pow((y2-y1),2));
            var y = 0;
            var inCircle = 1-radius;
            while(y<=radius)	{
                // 8 areas of calculation
                addPixel( radius + x1, y + y1);
                addPixel( y + x1, radius + y1);
                addPixel(-radius + x1, y + y1);
                addPixel(-y + x1, radius + y1);
                addPixel(-radius + x1,-y + y1);
                addPixel(-y + x1,-radius + y1);
                addPixel( radius + x1,-y + y1);
                addPixel( y + x1,-radius + y1);
                y++;
                if (inCircle<=0) {
                    inCircle += 2*y+1;
                } else {
                    radius--;
                    inCircle += 2*(y-radius)+1;
                }
            }
        }

        /* create regular polygon using line method */
        function myRegularPolygon(x1,y1,x2,y2,n) {
            if (n<3) {
                alert("polygon value must be greater than 2");
                return;
            }
            var x = [];
            var y = [];
            var centre = [x2,y2];
            var radius = Math.sqrt(Math.pow((x2-x1),2) + Math.pow((y2-y1),2));
            var theta = 2*Math.PI/n;
            for (var i = -1; i <= n; i++) {
                x[i] = radius * Math.cos(2*Math.PI*i/n + theta) + centre[0];
                y[i] = radius * Math.sin(2*Math.PI*i/n + theta) + centre[1];
                var a = x[i-1];
                var b = y[i-1];
                console.log(a,b,x[i],y[i]);
                myLine(a,b,x[i],y[i]);
            }
        }

        /* create bezier curve using 4 points and 0<t<1 */
        function bezier(x1, y1, x2, y2, x3, y3, x4, y4, t) {
            if ((t>1) || (t<0)) return;
            var temp = 0;
            var xOne = Math.pow((1-temp),3)*x1+3*(Math.pow((1-temp),2))*temp*x2+3*(1-temp)*Math.pow(temp,2)*x3+Math.pow(temp,3)*x4;
            var yOne = Math.pow((1-temp),3)*y1+3*(Math.pow((1-temp),2))*temp*y2+3*(1-temp)*Math.pow(temp,2)*y3+Math.pow(temp,3)*y4;
            while(temp<1) {
                temp = temp+t;
                var xTwo = Math.pow((1-temp),3)*x1+3*(Math.pow((1-temp),2))*temp*x2+3*(1-temp)*Math.pow(temp,2)*x3+Math.pow(temp,3)*x4;
                var yTwo = Math.pow((1-temp),3)*y1+3*(Math.pow((1-temp),2))*temp*y2+3*(1-temp)*Math.pow(temp,2)*y3+Math.pow(temp,3)*y4;
                myLine(xOne, yOne, xTwo, yTwo);
                xOne = xTwo;
                yOne = yTwo;
            }
        }

        /* get 2 points from clicks array and set them to draw a line */
        function setTwoPoints() {
            if (clicks.length === 2) {
                var tempA = clicks.pop();
                var tempB = clicks.pop();
                secondPoint.y = tempA[1];
                secondPoint.x = tempA[0];
                //console.log(clicks);
                thirdPoint.y = tempB[1];
                thirdPoint.x = tempB[0];
                //console.log(thirdPoint.x,thirdPoint.y,secondPoint.x,secondPoint.y);
            }
        }

        /* get 4 points from clicks array and set them to draw a line */
        function setFourPoints() {
            if (clicks.length === 4) {
                var tempA = clicks.pop();
                var tempB = clicks.pop();
                var tempC = clicks.pop();
                var tempD = clicks.pop();
                secondPoint.y = tempA[1];
                secondPoint.x = tempA[0];
                thirdPoint.y = tempB[1];
                thirdPoint.x = tempB[0];
                fourPoint.y = tempC[1];
                fourPoint.x = tempC[0];
                fivePoint.y = tempD[1];
                fivePoint.x = tempD[0];
                //console.log(clicks);
            }
        }

        /* check chosen function */
        function checkChosenFunc() {
            var func = chooseFunction.options[chooseFunction.selectedIndex].value;
            //console.log("function number " + func);
            switch(func) {
                case "0":
                    console.log("please choose a function");
                    break;
                case "1":
                    addPixel(point.x,point.y);
                    break;
                case "2":
                    setTwoPoints();
                    if ((secondPoint.x !== 0)&&(secondPoint.y !== 0)&&(thirdPoint.x !== 0)&&(thirdPoint.y !== 0))
                        myLine(thirdPoint.x,thirdPoint.y,secondPoint.x,secondPoint.y);
                    break;
                case "3":
                    setTwoPoints();
                    if ((secondPoint.x !== 0)&&(secondPoint.y !== 0)&&(thirdPoint.x !== 0)&&(thirdPoint.y !== 0))
                        myCircle(thirdPoint.x,thirdPoint.y,secondPoint.x,secondPoint.y);
                    break;
                case "4":
                    setTwoPoints();
                    if ((secondPoint.x !== 0)&&(secondPoint.y !== 0)&&(thirdPoint.x !== 0)&&(thirdPoint.y !== 0))
                        myRegularPolygon(thirdPoint.x,thirdPoint.y,secondPoint.x,secondPoint.y,globalN);
                    break;
                case "5":
                    setFourPoints();
                    if ((secondPoint.x !== 0)&&(secondPoint.y !== 0)&&(thirdPoint.x !== 0)&&(thirdPoint.y !== 0)&&
                        (fourPoint.x !== 0)&&(fourPoint.y !== 0)&&(fivePoint.x !== 0)&&(fivePoint.y !== 0))
                            bezier(thirdPoint.x,thirdPoint.y,secondPoint.x,secondPoint.y,
                                fourPoint.x,fourPoint.y,fivePoint.x,fivePoint.y,globalN);
                    break;
            }
        }

        /* EX2 functions */
        /* load everything related to the ship package */
        function loadPackage(){
            createPicOptionMenu(); //load the package
            loadUserManual(); //load guide to use the functions
        }

        /* dynamic create the ship picture menu, and only single time */
        function createPicOptionMenu(){
            //console.log("loaded menu");
            if (!isPicMenuExist) {
                var packageDiv = document.getElementById("packageDiv");
                //Create array of options to be added
                var array = ["","Load File","Move Picture","Center Picture","Zoom In","Zoom Out",
                    "Rotate Right","Rotate Left","Mirror xAxis","Mirror yAxis","Shearing X"];

                //Create and append select list
                var selectList = document.createElement("select");
                selectList.id = "shipOptions";
                packageDiv.appendChild(selectList);

                //Create and append the options
                for (var i = 0; i < array.length; i++) {
                    var option = document.createElement("option");
                    option.value = i;
                    option.text = array[i];
                    selectList.appendChild(option);
                }

                //Create input for ship rotations
                var shipLabel = document.createElement("label");
                var inputArea = document.createElement("input");
                shipLabel.innerHTML="Input for functions: ";
                inputArea.id = "shipInput";
                packageDiv.appendChild(shipLabel);
                shipLabel.appendChild(inputArea);

                isPicMenuExist=true;
                //after creating the menu, adding an event listener for the option list
                selectList.addEventListener("change",checkChosenFuncPic);
                //create event listener for ship input
                var shipInput = document.querySelector('#shipInput');
                shipInput.addEventListener("change",updateShipInput);
            }
        }

        /* will load guide about how to use the package */
        function loadUserManual(){
            console.log("load the guide");
            document.getElementById('light').style.display='block';
            document.getElementById('fade').style.display='block'
        }

        /* ajax call to load json file */
        function fetchJSONFile(path, callback) {
            var httpRequest = new XMLHttpRequest();
            httpRequest.onreadystatechange = function() {
                if (httpRequest.readyState === 4) {
                    if (httpRequest.status === 200) {
                        var data = JSON.parse(httpRequest.responseText);
                        if (callback) callback(data);
                    }
                }
            };
            httpRequest.open('GET', path);
            httpRequest.send();
        }

        /* print the vector picture to the screen */
        function drawPic () {
            var shapeCounter = 0;
            while(shapeCounter<picture[0].length) {
                myCircle(picture[0][shapeCounter][0],picture[0][shapeCounter][1],picture[0][shapeCounter][2],picture[0][shapeCounter][3]);
                shapeCounter++;
            }
            shapeCounter=0;
            while(shapeCounter<picture[1].length) {
                myLine(picture[1][shapeCounter][0],picture[1][shapeCounter][1],picture[1][shapeCounter][2],picture[1][shapeCounter][3]);
                shapeCounter++;
            }
            shapeCounter=0;
            while(shapeCounter<picture[2].length) {
                bezier(picture[2][shapeCounter][0],picture[2][shapeCounter][1],picture[2][shapeCounter][2],picture[2][shapeCounter][3],picture[2][shapeCounter][4],
                    picture[2][shapeCounter][5],picture[2][shapeCounter][6],picture[2][shapeCounter][7],picture[2][shapeCounter][8]);
                shapeCounter++;
            }
        }

        /* load json file and split it into arrays of shapes[circles,lines,beziers] */
        function loadAndSplit(){
            fetchJSONFile('includes/ship.json',function (data) {
                console.log(data);
                if (data.circle !== undefined) {
                    // get circles
                    for(var row=0; row<data.circle.length; row++) {
                        circlesInPic[row] = [];
                        circlesInPic[row][0] = data.circle[row].x1;
                        circlesInPic[row][1] = data.circle[row].y1;
                        circlesInPic[row][2] = data.circle[row].x2;
                        circlesInPic[row][3] = data.circle[row].y2;
                    }
                }
                if (data.line !== undefined) {
                    //get lines
                    for(row=0;row<data.line.length;row++) {
                        linesInPic[row] = [];
                        linesInPic[row][0] = data.line[row].x1;
                        linesInPic[row][1] = data.line[row].y1;
                        linesInPic[row][2] = data.line[row].x2;
                        linesInPic[row][3] = data.line[row].y2;
                    }
                }
                if (data.curve !== undefined) {
                    /// get curves
                    for(row=0;row<data.curve.length;row++) {
                        bezierInPic[row] = [];
                        bezierInPic[row][0] = data.curve[row].x1;
                        bezierInPic[row][1] = data.curve[row].y1;
                        bezierInPic[row][2] = data.curve[row].x2;
                        bezierInPic[row][3] = data.curve[row].y2;
                        bezierInPic[row][4] = data.curve[row].x3;
                        bezierInPic[row][5] = data.curve[row].y3;
                        bezierInPic[row][6] = data.curve[row].x4;
                        bezierInPic[row][7] = data.curve[row].y4;
                        bezierInPic[row][8] = data.curve[row].t;
                    }
                }
                picture[0] = circlesInPic; //will hold the circles inside the shape
                picture[1] = linesInPic;    //will hold the lines inside the shape
                picture[2] = bezierInPic;   //will hold the bezier inside the shape
                drawPic();
            });
        }

        /*  move picture to different location */
        function movePic(newX, newY) {
            //clear canvas
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            //calculate the x and y position difference between the initial point and the click
            const deferenceX= initialShipPointX-newX;
            const deferenceY= initialShipPointY-newY;
            //console.log("the difference is: "+deferenceX+","+deferenceY);
            for (var j=0;j<3;j++){  //loop over shapes kind array
                for (var i=0;i<picture[j].length;i++) { //loop over the rows of each shape array
                    var t;
                    if (j===2) { // if the shape is bezier, avoid touching the "t" parameter
                        for (t = 0; t < picture[j][i].length-1; t++) {
                            t % 2 === 0 ? picture[j][i][t] -= deferenceX : picture[j][i][t] -= deferenceY;
                        }
                    } else{
                        for (t = 0; t < picture[j][i].length; t++) {
                            t % 2 === 0 ? picture[j][i][t] -= deferenceX : picture[j][i][t] -= deferenceY;
                        }
                    }
                }
            }
            drawPic();
            initialShipPointX=newX;
            initialShipPointY=newY;
            //console.log("new point "+initialShipPointX+","+initialShipPointY);
        }

        /*  zoom in/out depends on a click location */
        function zoomPic(zoomX, zoomY,zoomIndex ) {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            const deferenceX= initialShipPointX-zoomX;
            const deferenceY= initialShipPointY-zoomY;

            for (var j=0;j<3;j++){  //loop over shapes kind array
                for (var i=0;i<picture[j].length;i++) { //loop over the rows of each shape array
                    var t;
                    if (j===2) { // if the shape is bezier, avoid touching the "t" parameter
                        for (t = 0; t < picture[j][i].length-1; t++) {
                            if(t % 2 === 0){
                                picture[j][i][t] = initialShipPointX+ ((picture[j][i][t] -initialShipPointX)*zoomIndex)+ deferenceX * zoomIndex;
                            }else{
                                picture[j][i][t] = initialShipPointY+ ((picture[j][i][t] -initialShipPointY)*zoomIndex)+ deferenceY * zoomIndex;
                            }
                        }
                    } else{
                        for (t = 0; t < picture[j][i].length; t++) {
                            if(t % 2 === 0){
                                picture[j][i][t] = initialShipPointX+ ((picture[j][i][t] -initialShipPointX)*zoomIndex)+ deferenceX * zoomIndex;
                            }else{
                                picture[j][i][t] = initialShipPointY+ ((picture[j][i][t] -initialShipPointY)*zoomIndex)+ deferenceY * zoomIndex;
                            }
                        }
                    }
                }
            }
            drawPic();
            initialShipPointX=zoomX;
            initialShipPointY=zoomY;
        }

        /*  center the picture */
        function centerPic(){
            point.x=canvasWidth/2;
            point.y=canvasHeight/2;
            movePic(point.x,point.y);
        }

        /*  update the rotation value */
        function updateShipInput() {
            globalDegree = shipInput.value;
        }

        /* calculation algoritem function for rotation */
        function calculationForRotate(x,y,rotateRad,j,i,t){
            var radius = Math.sqrt(Math.pow((picture[j][i][t]-x),2)+Math.pow((picture[j][i][t+1]-y),2));
            var current = picture[j][i][t];
            if((picture[j][i][t+1]-y)<0) {
                picture[j][i][t] = radius*(Math.cos(rotateRad-(Math.acos((Math.pow((picture[j][i][t]-x),2)
                            +Math.pow(radius,2)-Math.pow((picture[j][i][t+1]-y),2))/(2*(picture[j][i][t]-x)*radius)))))+x;
                picture[j][i][t+1] = radius*(Math.sin(rotateRad-(Math.acos((Math.pow((current-x),2)
                            +Math.pow(radius,2)-Math.pow((picture[j][i][t+1]-y),2))/(2*(current-x)*radius)))))+y;
            } else {
                picture[j][i][t] = radius*(Math.cos(rotateRad+(Math.acos((Math.pow((picture[j][i][t]-x),2)
                            +Math.pow(radius,2)-Math.pow((picture[j][i][t+1]-y),2))/(2*(picture[j][i][t]-x)*radius)))))+x;
                picture[j][i][t+1] = radius*(Math.sin(rotateRad+(Math.acos((Math.pow((current-x),2)
                            +Math.pow(radius,2)-Math.pow((picture[j][i][t+1]-y),2))/(2*(current-x)*radius)))))+y;
            }
        }

        /*  rotate the picture */
        function rotatePic(x, y , degree) {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            var rotateRad = (degree*Math.PI)/180;

            for (var j=0;j<3;j++){  //loop over shapes kind array
                for (var i=0;i<picture[j].length;i++) { //loop over the rows of each shape array
                    var t;
                    if (j===2) { // if the shape is bezier, avoid touching the "t" parameter
                        for (t = 0; t < picture[j][i].length-1; t+=2) {
                            calculationForRotate(x,y,rotateRad,j,i,t);
                        }
                    } else{
                        for (t = 0; t < picture[j][i].length; t+=2) {
                            calculationForRotate(x,y,rotateRad,j,i,t);
                        }
                    }
                }
            }
            drawPic();
        }

        /*  mirror the picture */
        function mirrorPic(x,y,axis) {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            var axisToChange = axis === 0 ? 0 : 1;  //if axis===0 mirror x, else mirror y
            var axisValue = axis === 0 ? x : y;     //if axis===0 mirror x, else mirror y
            for (var j=0;j<3;j++){  //loop over shapes kind array
                for (var i=0;i<picture[j].length;i++) { //loop over the rows of each shape array
                    var t = axisToChange;
                    if (j===2) { // if the shape is bezier, avoid touching the "t" parameter
                        for (t ; t < picture[j][i].length-1; t+=2) {
                            picture[j][i][t]=picture[j][i][t]-(picture[j][i][t]-axisValue)*2;
                        }
                    } else{
                        for (t; t < picture[j][i].length; t+=2) {
                            picture[j][i][t]=picture[j][i][t]-(picture[j][i][t]-axisValue)*2;
                        }
                    }
                }
            }
            drawPic();
        }

        /*  shearing function, relative to the button of the ship */
        function shearingPic (holdClickX, releaseClickX, holdClickY) {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            var shearPoint = 416; // bottom of the ship, shearing will be relative to this position
            var ShearingIndex = (holdClickX-releaseClickX)/(shearPoint-holdClickY);

            for (var j=0;j<3;j++){  //loop over shapes kind array
                for (var i=0;i<picture[j].length;i++) { //loop over the rows of each shape array
                    var t;
                    if (j===2) { // if the shape is bezier, avoid touching the "t" parameter
                        for (t=0; t < picture[j][i].length-1; t+=2) {
                            picture[j][i][t] = picture[j][i][t]+(ShearingIndex*(picture[j][i][t+1]-shearPoint))
                        }
                    } else{
                        for (t=0; t < picture[j][i].length; t+=2) {
                            picture[j][i][t] = picture[j][i][t]+(ShearingIndex*(picture[j][i][t+1]-shearPoint))
                        }
                    }
                }
            }
            drawPic();
            canvas.removeEventListener("mousedown",mouseDown);
            canvas.removeEventListener("mouseup",mouseUp);
        }

        /*  set point for mouse down */
        function mouseDown(e){
            getRelativePoint(e);
            mouseDownX = point.x;
            mouseDownY = point.y;
        }

        /*  set point for mouse up */
        function mouseUp(e){
            getRelativePoint(e);
            mouseUpX = point.x;
            shearingPic(mouseDownX,mouseUpX,mouseDownY);
        }

        /*  ship json file transformation functions */
        function checkChosenFuncPic(){
            var func2 = shipOptions.options[shipOptions.selectedIndex].value;
            //console.log("function: " + func2);
            switch(func2) {
                case "0":
                    console.log("please choose a function");
                    break;
                case "1":
                    loadAndSplit();
                    break;
                case "2":
                    point.x===0 && point.y===0 ? alert("Select point to move the object into") : movePic(point.x,point.y);
                    break;
                case "3":
                    centerPic();
                    break;
                case "4":
                    point.x===0 && point.y===0 ? alert("Select the zoom point") : zoomPic(point.x,point.y,1.05);
                    break;
                case "5":
                    point.x===0 && point.y===0 ? alert("Select the zoom point") : zoomPic(point.x,point.y,0.95);
                    break;
                case "6":
                    point.x===0 && point.y===0 ? alert("Select rotate left point") : rotatePic(point.x,point.y,globalDegree);
                    break;
                case "7":
                    point.x===0 && point.y===0 ? alert("Select rotate right point") : rotatePic(point.x,point.y,-1*globalDegree);
                    break;
                case "8":
                    point.x===0 && point.y===0 ? alert("Select Mirror x axis") : mirrorPic(point.x,point.y,0);
                    break;
                case "9":
                    point.x===0 && point.y===0 ? alert("Select Mirror y axis") : mirrorPic(point.x,point.y,1);
                    break;
                case "10":
                    canvas.addEventListener("mousedown",mouseDown);
                    canvas.addEventListener("mouseup",mouseUp);
                    break;
            }
        }
    </script>
</body>
</html>